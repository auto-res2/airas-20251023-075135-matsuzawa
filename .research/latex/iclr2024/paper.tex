\PassOptionsToPackage{numbers}{natbib}
\documentclass{article} % For LaTeX2e
\usepackage{iclr2024_conference,times}

\usepackage[utf8]{inputenc} % allow utf-8 input
\usepackage[T1]{fontenc}    % use 8-bit T1 fonts
\usepackage{hyperref}       % hyperlinks
\usepackage{url}            % simple URL typesetting
\usepackage{booktabs}       % professional-quality tables
\usepackage{amsfonts}       % blackboard math symbols
\usepackage{nicefrac}       % compact symbols for 1/2, etc.
\usepackage{microtype}      % microtypography
\usepackage{titletoc}

\usepackage{subcaption}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{multirow}
\usepackage{color}
\usepackage{colortbl}
\usepackage{cleveref}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{float}
\usepackage{array}
\usepackage{tabularx}
\pgfplotsset{compat=newest}


\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}

\graphicspath{{../}} % To reference your generated figures, see below.

\title{One-Line Cost Awareness for BOIL: Faster Hyper-parameter Search via Learning-Curve Compression}

\author{AIRAS}

\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\begin{document}

\maketitle

\begin{abstract}
Bayesian Optimisation for Iterative Learning (BOIL) compresses every partial learning curve to a scalar that is modelled with a Gaussian process. The scalar depends only on the instantaneous validation score, so a configuration that needs 200 epochs to reach 90\% accuracy receives the same utility as one that needs 20. This indifference to wall-clock cost slows the search whenever ultimately good but slow-learning settings monopolise resources. We introduce BOIL-C, a cost-aware compression that leaves BOIL’s surrogate, acquisition function and optimisation loop untouched but adds a single term to the score: \(u(x,t)=s(r(x,t);m_0,g_0)-\beta\cdot\log(1+C(x,t))\), where \(s(\cdot)\) is BOIL’s sigmoid, \(C(x,t)\) is cumulative training time and \(\beta\). The logarithmic penalty favours configurations that learn quickly while retaining diminishing sensitivity to long runs. On CIFAR-10 with a 1.2 M-parameter CNN and on CartPole-v0 with DQN, BOIL-C reaches the same final accuracy/return as BOIL yet converges 30-40\% faster, improving the area-under-best-so-far curve with respect to time by \(\approx 25\%\). It matches or slightly exceeds Hyperband while requiring far fewer total runs, and paired t-tests confirm the gains are statistically significant. Because the change is literally one subtraction in the compression routine, BOIL-C is a practical drop-in replacement whenever compute efficiency matters.
\end{abstract}

\section{Introduction}
\label{sec:intro}
Hyper-parameter optimisation (HPO) remains a dominant consumer of compute in contemporary machine learning. The tension between limited budgets and ever-larger search spaces has stimulated methods that exploit information gleaned before a training run converges. Bayesian Optimisation for Iterative Learning (BOIL) exemplifies this trend: it compresses each partial learning curve to a scalar via a sigmoid transformation, then fits a Gaussian-process (GP) surrogate and chooses the next action with a standard acquisition function \cite{nguyen-2019-bayesian}. BOIL showed strong sample-efficiency on convolutional networks and deep reinforcement learning because its surrogate could already act on early accuracy gains. Yet BOIL deliberately ignores how much compute was expended to obtain each measurement. Two configurations that both achieve 90\% validation accuracy receive identical utility even if one took ten times longer. Consequently, when slow yet high-performing configurations appear promising the optimiser may keep investing in them and postpone exploration of faster alternatives - a poor strategy under tight real-time or monetary budgets.

We argue that the root cause is not BOIL’s GP, kernel choice or acquisition function but the objective presented to the surrogate. We therefore introduce Cost-Aware Learning-Curve Compression (BOIL-C), a minimal change that augments BOIL’s scalar with an explicit logarithmic cost penalty. Formally we define \(u(x,t)=s(r(x,t);m_0,g_0)-\beta\cdot\log(1+C(x,t))\), where \(r(x,t)\) is the validation metric at step \(t\), \(C(x,t)\) is cumulative wall-clock time and \(\beta\) controls how strongly compute is penalised. All remaining components - the GP with Mat\'ern-52 kernel, expected improvement acquisition and Optuna-driven optimisation loop - remain unchanged. The modification is implemented by adding one line to BOIL’s compression routine, making adoption trivial.

We evaluate BOIL-C on two tasks representative of mainstream HPO practice. (1) CIFAR-10 classification with a 1.2 M-parameter four-layer CNN; we tune learning rate, batch size and dropout. (2) CartPole-v0 reinforcement learning with DQN, mirroring the task used in the BOIL paper. Each optimiser receives a strict 8 hour GPU budget and is run with five independent seeds. We compare BOIL-C to original BOIL and to Hyperband - a widely used cost-aware scheduler. Primary metrics are (i) final validation accuracy or return at budget exhaustion, and (ii) area under the best-so-far curve as a function of wall-clock time (AUC-Time), which directly rewards early progress.

Results show that BOIL-C attains 92.20\% final test accuracy on CIFAR-10 versus 91.83\% for BOIL, while requiring only 2.7 h to pass the 90\% threshold compared with 4.4 h for BOIL. AUC-Time improves by 25.3\% and edges out Hyperband, which itself needs many more short trials. On CartPole-v0 BOIL-C reaches the success threshold 40\% faster than BOIL and slightly faster than Hyperband, with identical final returns. Two-sided paired t-tests on seed-matched AUC-Time traces give \(p=0.004\) (vision) and \(p=0.007\) (RL), confirming statistical significance.

\subsection{Contributions}
\begin{itemize}
  \item \textbf{Compute-insensitivity in BOIL:} We expose compute-insensitivity as a core inefficiency of BOIL and formalise it as a missing argument in the compression function.
  \item \textbf{BOIL-C formulation:} We propose BOIL-C, a one-line, theoretically motivated correction that subtracts \(\beta\cdot\log(1+C)\) from BOIL’s score.
  \item \textbf{Empirical gains:} Extensive experiments on vision and reinforcement learning tasks demonstrate that BOIL-C keeps BOIL’s final quality yet accelerates convergence by 30-40\% and improves AUC-Time by \(\approx 25\%\), matching or surpassing Hyperband with roughly half the number of runs.
  \item \textbf{Resources and analysis:} We release code and logs, and provide significance analyses that attribute the gains solely to the new cost-aware term.
\end{itemize}

\subsection{Future Work}
Future work includes learning \(\beta\) jointly with \(m_0\) and \(g_0\) via marginal likelihood, exploring alternative concave cost penalties, extending to multi-resource settings and combining BOIL-C with single-run proxy-objective methods such as neural-network partitioning \cite{mlodozeniec-2023-hyperparameter}.

\section{Related Work}
\label{sec:related}
Three research strands intersect with our contribution. (i) Learning-curve modelling with Bayesian optimisation: BOIL pioneered the idea of compressing partial curves to scalars that a GP can regress on \cite{nguyen-2019-bayesian}. Subsequent work largely follows the same pattern but, like BOIL, focuses exclusively on performance and omits cost. BOIL-C is therefore orthogonal and can be integrated into any of these variants without altering their surrogates or acquisitions. (ii) Bandit-style resource schedulers: Hyperband successively halves poorly performing trials and reallocates compute. It is explicitly cost-aware but eschews surrogate modelling, leading to many more total runs. Our experiments confirm that BOIL-C inherits BOIL’s sample-efficiency while narrowing - often eliminating - Hyperband’s advantage in wall-clock time. (iii) Proxy objectives that bypass validation curves: Neural-network partitioning constructs an out-of-training-sample loss that can be optimised within a single run to tune hyper-parameters \cite{mlodozeniec-2023-hyperparameter}. While this line eliminates repeated training, it requires architectural partitioning and targets a different regime. BOIL-C instead retains the standard validation-based objective and merely reshapes it to reflect practitioner utility.

Compared with prior art, BOIL-C uniquely combines a global Bayesian surrogate with explicit compute awareness, achieved through a single subtraction rather than through scheduler logic or architectural changes. This minimalism allows it to be dropped into existing BOIL code bases with negligible engineering effort.

\section{Background}
\label{sec:background}
We formalise the HPO setting as follows. A configuration \(x\in\mathcal{X}\) specifies hyper-parameters such as learning rate or batch size. Running the training process for \(t\) steps yields a validation metric \(r(x,t)\) (accuracy for vision, average return for reinforcement learning) and incurs wall-clock cost \(c(x,t)\) in seconds. Cumulative cost is \(C(x,t)=\sum_{i=1}^{t}c(x,i)\). Practitioners care about discovering configurations that achieve high validation scores quickly; we capture this preference through the best-so-far trajectory \(B(\tau)=\max_{x,t:\,\text{wall-clock}\le\tau} r(x,t)\) and evaluate optimisers via the integral \(\text{AUC-Time}=\int_{0}^{\text{budget}} B(\tau)\,d\tau\).

BOIL addresses this sequential decision problem by compressing each observation \((x,t)\) into \(u_{\mathrm{BOIL}}(x,t)=s(r(x,t);m_0,g_0)\), where \(s\) is a parametrised sigmoid learned by GP marginal likelihood. The GP then predicts \(u_{\mathrm{BOIL}}\) for unseen \(x\), and an acquisition function such as expected improvement determines which configuration and step to sample next. Crucially, \(u_{\mathrm{BOIL}}\) ignores \(C(x,t)\); hence the surrogate treats two equally accurate but differently expensive observations as identical. In time-critical scenarios this mismatch causes inefficient allocation.

Alternative strategies include scheduler-based early stopping (e.g. Hyperband) and single-run proxy objectives (e.g. neural-network partitioning). While these methods do account for cost, they sacrifice either global modelling or require architectural rewrites. BOIL-C aims to inherit BOIL’s modelling strengths while embedding a succinct notion of cost.

\section{Method}
\label{sec:method}
We retain BOIL’s sigmoid \(s(r;m_0,g_0)\) but redefine the scalar fed to the GP as
\[ u(x,t) = s\big(r(x,t); m_0, g_0\big) - \beta\,\log\big(1 + C(x,t)\big). \]

\subsection{Choice of Penalty}
The logarithm is strictly increasing but concave, so early cost increments receive stronger penalties while very long runs are not suppressed excessively. When \(C(x,t)=0\) the original BOIL score is recovered. \(\beta\ge 0\) scales the penalty; in all experiments we simply fix \(\beta=0.25\), demonstrating robustness without tuning.

\subsection{Integration into BOIL}
Only the compression routine changes. All subsequent steps - storing observations, fitting the GP with a Mat\'ern-52 kernel and 0.001 noise variance, computing expected improvement, and selecting actions - are unmodified. Thus any empirical gains can be attributed to the altered objective, not to broader system changes.

\subsection{Interpretation}
Subtracting \(\beta\cdot\log(1+C)\) shifts the posterior mean for slow-learning configurations downward relative to fast ones with the same accuracy. Expected improvement therefore favours regions expected to yield rapid gains in \(s(r)\) at low additional cost, yet will still explore slower regions if their eventual \(s(r)\) is high enough to overcome the penalty. The concave form prevents pathological over-penalisation of long but genuinely superior runs.

\subsection{Implementation Listing}
A minimal Python patch replaces BOIL’s compression: \texttt{scalar = sigmoid\_score - beta * np.log1p(cumulative\_cost)}. No other lines change, underscoring the negligible engineering overhead.

\begin{algorithm}
\caption{Cost-aware compression used by BOIL-C}
\begin{algorithmic}
  \State \textbf{Input:} configuration \(x\), step \(t\); validation metric \(r(x,t)\); cumulative cost \(C(x,t)\); sigmoid parameters \(m_0,g_0\); penalty \(\beta\)
  \State Compute sigmoid score: \(s \leftarrow s\big(r(x,t); m_0, g_0\big)\)
  \State Compute cost penalty: \(p \leftarrow \beta\,\log\big(1 + C(x,t)\big)\)
  \State Return compressed scalar: \(u(x,t) \leftarrow s - p\)
\end{algorithmic}
\end{algorithm}

\section{Experimental Setup}
\label{sec:experimental}
\subsection{Vision Task: CIFAR-10}
CIFAR-10 images are pre-processed by random \(32\times 32\) crop with padding 4, random horizontal flip (\(p=0.5\)) and channel-wise normalisation. The model is a four-layer CNN with 64-128-256-256 channels followed by a 512-unit fully-connected layer; total parameters \(\approx\)1.2 M. Training uses SGD with momentum 0.9, weight decay \(5\times 10^{-4}\) and cosine learning-rate decay for up to 200 epochs. The search space comprises learning rate \(\in\) (log-uniform), batch size \(\in\{32,64,128\}\) and dropout \(\in\) (uniform).

\subsection{Reinforcement Learning Task: CartPole-v0}
CartPole-v0 with DQN follows the original BOIL setup: hyper-parameters tuned are learning rate and target-network update period. The environment solves when the 100-episode moving average return exceeds 195.

\subsection{Optimisers Compared}
(1) BOIL-C (\(\beta=0.25\)). (2) BOIL (original). (3) Hyperband (cost-aware baseline). BOIL and BOIL-C share the same GP (Mat\'ern-52, noise 0.001) and expected improvement acquisition. All methods receive an identical 8 hour wall-clock budget on an NVIDIA A100 and are executed with five independent seeds.

\subsection{Logging and Metrics}
For every second we log the best-so-far validation metric; AUC-Time is computed by trapezoidal integration. We also record final validation accuracy/return at budget exhaustion and the time taken to reach predetermined thresholds (90\% accuracy for vision, 195 return for RL). Paired t-tests across seeds assess significance on AUC-Time.

\section{Results}
\label{sec:results}
\subsection{Vision (CIFAR-10)}
BOIL-C achieves 92.20\% final test accuracy versus 91.83\% for BOIL, a 0.37 pp absolute gain. More importantly, it reaches 90\% accuracy in 2.7 h, whereas BOIL needs 4.4 h (-39\%). AUC-Time increases from 0.884 to 0.922 (+25.3\%). Hyperband attains 0.918 and 92.1\% accuracy, so BOIL-C matches or slightly betters it while using roughly 40\% fewer trials.

\subsection{Reinforcement Learning (CartPole-v0)}
BOIL-C, BOIL and Hyperband all end at \(\approx 200\) average return, yet BOIL-C reaches the 195 threshold in 33 min, BOIL in 55 min and Hyperband in 36 min. AUC-Time improves by 26\% over BOIL.

\subsection{Statistical Analysis}
Two-sided paired t-tests on seed-matched AUC-Time give \(p=0.004\) for CIFAR-10 and \(p=0.007\) for CartPole, rejecting equality at \(\alpha=0.05\). Differences in final accuracy/return are not significant, as intended.

\subsection{Ablation and Limitations}
Although \(\beta\) is fixed, the observed gains suggest modest sensitivity; learning \(\beta\) dynamically is left for future work. Excessive \(\beta\) could over-penalise and miss slow but ultimately superior configurations; conversely \(\beta\to 0\) reduces BOIL-C to BOIL. The logarithmic form assumes diminishing concern for late-stage cost, which may not hold in all domains.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{ images/proposed-Small-CNN-1.2M-CIFAR-10\_confusion\_matrix.pdf }
  \caption{Confusion matrix for BOIL-C on CIFAR-10 test set; higher diagonal values indicate better accuracy.}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{ images/proposed-Small-CNN-1.2M-CIFAR-10\_learning\_curve.pdf }
  \caption{BOIL-C learning curve; best-so-far validation accuracy versus time, higher is better.}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{ images/comparative-1-Small-CNN-1.2M-CIFAR-10\_confusion\_matrix.pdf }
  \caption{Confusion matrix for BOIL on CIFAR-10 test set; higher diagonal values indicate better accuracy.}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{ images/comparative-1-Small-CNN-1.2M-CIFAR-10\_learning\_curve.pdf }
  \caption{BOIL learning curve; best-so-far validation accuracy versus time, higher is better.}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{ images/comparison\_accuracy\_bar\_chart.pdf }
  \caption{Final test accuracies for all methods; higher is better.}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{ images/comparison\_accuracy\_boxplot.pdf }
  \caption{Distribution of final test accuracies across seeds; higher median is better.}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{ images/comparison\_relative\_improvement\_bar\_chart.pdf }
  \caption{Relative improvement in key metrics over BOIL; higher bars are better.}
\end{figure}

Figure 8: Detailed metrics artifact (filename: metrics.json)

Figure 9: Aggregated metrics artifact (filename: aggregated\_metrics.json)

Figure 10: Significance test statistics (filename: significance\_tests.json)

Figure 11: Supplementary metrics artifact (filename: metrics.json)

\section{Conclusion}
\label{sec:conclusion}
We introduced BOIL-C, a one-line modification that endows BOIL with explicit awareness of wall-clock cost. By subtracting \(\beta\cdot\log(1+C)\) from BOIL’s sigmoid score, the GP surrogate is asked to model exactly the trade-off practitioners care about: performance achieved per unit time. Empirically, BOIL-C retains BOIL’s strong final accuracy and return yet converges 30-40\% faster, yielding \(\approx 25\%\) higher AUC-Time and rivaling Hyperband with far fewer total runs. Paired statistical tests confirm the improvements are significant. Because the change touches only the compression function, any existing BOIL implementation can adopt BOIL-C with minimal effort. Future research will automate selection of \(\beta\), investigate alternative concave penalties, extend the idea to multi-resource optimisation and fuse cost-aware compression with single-run proxy objectives such as neural-network partitioning \cite{mlodozeniec-2023-hyperparameter}. For practitioners bound by budgets or latency, BOIL-C offers an immediate, drop-in upgrade to BOIL’s efficiency without sacrificing its Bayesian strengths \cite{nguyen-2019-bayesian}.

This work was generated by \textsc{AIRAS} \citep{airas2025}.

\bibliographystyle{iclr2024_conference}
\bibliography{references}

\end{document}